  // Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <vector>
#include <algorithm>
#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

//  block 格式：
//        string       string      Fixedint32       Fixedint32    Fixedint32
//        +--------------+--------------+--------------+--------------+-----------------+
//        | entries[0]   | entries[n]   | restart[0]   | restart[n]   | num_restarts    |
//        +--------------+--------------+--------------+--------------+-----------------+
    // 从文件尾部解析出 num_restarts
    inline uint32_t Block::NumRestarts() const {
        assert(size_ >= sizeof(uint32_t));
        return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
    }

    // TODO: owned_
    Block::Block(const BlockContents &contents)
            : data_(contents.data.data()),
              size_(contents.data.size()),
              owned_(contents.heap_allocated) {
        if (size_ < sizeof(uint32_t)) {
            size_ = 0;  // Error marker
        } else {
            size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
            if (NumRestarts() > max_restarts_allowed) {
                // The size is too small for NumRestarts()
                size_ = 0;
            } else {
                restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
            }
        }
    }

    Block::~Block() {
        if (owned_) {
            delete[] data_;
        }
    }

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).

//  block 格式：
//                       p            limit
//        +--------------+--------------+--------------+--------------+-----------------+
//        | entries[0]   | entries[i]   | restart[0]   | restart[i]   | num_restarts    |
//        +--------------+--------------+--------------+--------------+-----------------+

    // 给定字符串头 *P 和串尾 *limit，返回三个值
    // shared 表示和前一个 entry 共享的 key 的长度
    // non_shared 表示除共享 key 剩下的长度
    // value_length 表示 data 的长度

    // 函数作用: 给定 restart point[i], p指向 entries[i] 首地址，然后找到第一个 entry
    // 返回第一个 entry 的首地址
    // 只找一个就行！而且是第一个！
    // limit 用于保证不会越界
    static inline const char *DecodeEntry(const char *p, const char *limit,
                                          uint32_t *shared,
                                          uint32_t *non_shared,
                                          uint32_t *value_length) {
        // 这两个 if 只是一个优化，真正用的多的还是下面的 else 分支
        if (limit - p < 3) return nullptr;
        // 这里并不是说每个长度值都只占一个字节
        *shared = reinterpret_cast<const unsigned char *>(p)[0];
        *non_shared = reinterpret_cast<const unsigned char *>(p)[1];
        *value_length = reinterpret_cast<const unsigned char *>(p)[2];
        // 代表每个长度都小于127， 即一位字节编码就够了。
        if ((*shared | *non_shared | *value_length) < 128) {
            // Fast path: all three values are encoded in one byte each
            p += 3;
        }

        else {
            if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
            if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
            if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
        }
        // 若剩下字符串的长度不足 key 的 non_shared 部分长度加上value长度，则返回空
        // 保证不会越界
        if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
            return nullptr;
        }
        // p指向 key 和 value 的 data 部分
        return p;
    }

    class Block::Iter : public Iterator {
    private:

//  block 格式：
//        data_
//        +------------+------------+--------------+--------------+-----------------+
//        | entry[0]   | entry[n]   | restart[0]   | restart[n]   | num_restarts    |
//        +------------+------------+--------------+--------------+-----------------+
        const Comparator *const comparator_;
        const char *const data_;      // BlockContents.data
        uint32_t const restarts_;     // 上面 restart[0] 在 block 中的偏移量
        uint32_t const num_restarts_; // restart point 的数量


        uint32_t current_;              // 该变量指向当前 iter 指向的 entry 在文件内的偏移量,如果大于 restarts_，属于非法
        uint32_t restart_index_;        // current_ 落在哪一个 restart point 内，该值就是哪个 restart point 的在文件内的偏移量
        std::string key_;               // 解析出来的 key
        Slice value_;                   // 解析出来的 value
        Status status_;

        inline int Compare(const Slice &a, const Slice &b) const {
            return comparator_->Compare(a, b);
        }

        // Return the offset in data_ just past the end of the current entry.
        // 返回下一个 entry.shared 的偏移量
        inline uint32_t NextEntryOffset() const {
            return (value_.data() + value_.size()) - data_;
        }

        // 返回 restart point[i] 指向的具体 entries[] 在文件中的偏移量
        uint32_t GetRestartPoint(uint32_t index) {
            assert(index < num_restarts_);
            return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
        }

        void SeekToRestartPoint(uint32_t index) {
            key_.clear();
            restart_index_ = index;
            // current_ will be fixed by ParseNextKey();

            // ParseNextKey() starts at the end of value_, so set value_ accordingly
            // offset 记录了 restart point 内第一个 entry.value 的偏移量
            uint32_t offset = GetRestartPoint(index);
            value_ = Slice(data_ + offset, 0);
        }

    public:
        Iter(const Comparator *comparator,
             const char *data,
             uint32_t restarts,
             uint32_t num_restarts)
                : comparator_(comparator),
                  data_(data),
                  restarts_(restarts),
                  num_restarts_(num_restarts),
                  current_(restarts_),
                  restart_index_(num_restarts_) {
            assert(num_restarts_ > 0);
        }

        virtual bool Valid() const { return current_ < restarts_; }

        virtual Status status() const { return status_; }

        virtual Slice key() const {
            assert(Valid());
            return key_;
        }

        virtual Slice value() const {
            assert(Valid());
            return value_;
        }

        virtual void Next() {
            assert(Valid());
            ParseNextKey();
        }

        virtual void Prev() {
            assert(Valid());

            // Scan backwards to a restart point before current_
            const uint32_t original = current_;
            while (GetRestartPoint(restart_index_) >= original) {
                if (restart_index_ == 0) {
                    // No more entries
                    current_ = restarts_;
                    restart_index_ = num_restarts_;
                    return;
                }
                restart_index_--;
            }

            SeekToRestartPoint(restart_index_);
            do {
                // Loop until end of current entry hits the start of original entry
            } while (ParseNextKey() && NextEntryOffset() < original);
        }

        // target 是某个 entry 的 key
        // 先二分查找，使 restart_index_ 指向某个 index，
        // 然后在该 entries[index] 不停内调用 ParseNextKey 知道找到对应的 target 为止
        virtual void Seek(const Slice &target) {
            // Binary search in restart array to find the last restart point
            // with a key < target

            // left、right、mid 都是 restart point 的索引
            // 范围为 [0, n]
            uint32_t left = 0;
            uint32_t right = num_restarts_ - 1;
            while (left < right) {
                // 先 GetRestartPoint(mid) 找到 restart point[mid] 指向的具体 entries[mid] 的偏移量，
                // 再根据此偏移量调用 DecodeEntry()，找到 entries[mid] 中第一个 entry 的 key+value首地址指针
                // 即根据 entries[mid] 第一个 entry->key 的指针构造 mid_key

                uint32_t mid = (left + right + 1) / 2;
                uint32_t region_offset = GetRestartPoint(mid);  // restart point[mid] 在文件中的偏移量
                uint32_t shared, non_shared, value_length;
                const char *key_ptr = DecodeEntry(data_ + region_offset,
                                                  data_ + restarts_,
                                                  &shared, &non_shared, &value_length);
                if (key_ptr == nullptr || (shared != 0)) {
                    CorruptionError();
                    return;
                }
                Slice mid_key(key_ptr, non_shared); // 此处 shared == 0，所以根据 non_shared 能构造完整的key
                if (Compare(mid_key, target) < 0) {
                    // Key at "mid" is smaller than "target".  Therefore all
                    // blocks before "mid" are uninteresting.
                    left = mid;
                } else {
                    // Key at "mid" is >= "target".  Therefore all blocks at or
                    // after "mid" are uninteresting.
                    right = mid - 1;
                }
            }

            // Linear search (within restart block) for first key >= target
            SeekToRestartPoint(left);
            while (true) {
                if (!ParseNextKey()) {
                    return;
                }
                if (Compare(key_, target) >= 0) {
                    return;
                }
            }
        }

        virtual void SeekToFirst() {
            SeekToRestartPoint(0);
            ParseNextKey();
        }

        // 使迭代器指向最后一个 entry
        // 先 SeekToRestartPoint(), 使 value_.data() 指向 entries[n].shared 地址
        virtual void SeekToLast() {
            SeekToRestartPoint(num_restarts_ - 1);
            while (ParseNextKey() && NextEntryOffset() < restarts_) {
                // Keep skipping
            }
        }

    private:
        void CorruptionError() {
            current_ = restarts_;
            restart_index_ = num_restarts_;
            status_ = Status::Corruption("bad entry in block");
            key_.clear();
            value_.clear();
        }

        bool ParseNextKey() {
            current_ = NextEntryOffset();
            const char *p = data_ + current_;
            const char *limit = data_ + restarts_;  // Restarts come right after data
            if (p >= limit) {
                // No more entries to return.  Mark as invalid.
                current_ = restarts_;
                restart_index_ = num_restarts_;
                return false;
            }

            // Decode next entry
            uint32_t shared, non_shared, value_length;
            p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
            if (p == nullptr || key_.size() < shared) {
                CorruptionError();
                return false;
            } else {
                key_.resize(shared);
                key_.append(p, non_shared);
                value_ = Slice(p + non_shared, value_length);
                while (restart_index_ + 1 < num_restarts_ &&
                       GetRestartPoint(restart_index_ + 1) < current_) {
                    ++restart_index_;
                }
                return true;
            }
        }
    };

    Iterator *Block::NewIterator(const Comparator *cmp) {
        if (size_ < sizeof(uint32_t)) {
            return NewErrorIterator(Status::Corruption("bad block contents"));
        }
        const uint32_t num_restarts = NumRestarts();
        if (num_restarts == 0) {
            return NewEmptyIterator();
        } else {
            return new Iter(cmp, data_, restart_offset_, num_restarts);
        }
    }

}  // namespace leveldb
